<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Portfolio - Tomás Schuller</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #f18a02;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #f18a02;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #d2d2d7;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Portfolio - Tomás Schuller</p>
                        <p>Please input given password.</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="ENTER" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"287bf838e2a61732acde9fb576dc3fab44ccf3ad8f8fd2ef6293f945fa77cb3251352cfe0c5f9b29ed38c7d331df27144e43eb41ecef14cfc907b4b8518f06925fae199d5c41819760ef0213ec38f7844ae389c75f4c09dccded6d5ab4c5ee0154a51b3b9cebba52978602fe48a92efb49805a680bb6f101d27c9347b409a30016c925555097003c65a19bc43f3ed13956fac42ca419b008d605c7b945531f2e040bb380730f9d87b4d81ac8800cb11c5586fd732eb2c390bc21551d1814429b82860289a5f258e46132b866a77eed7d3998712a9c5fb32e58a777b79ab59dfa111ce772ef8361090b20008b2195d0dd7ab19f224530f06a83c833db23560ecf8d979bc95148e4f36c8039947c1f9daf7511ba87d0862e53d6e0cfb2fa15ef97b9505aca6f3ddabf28b04b4c0fb11c305bb3af533fc021970f135c3c2cb86fa58d51aa63fbae48a318ced0d1d7c52a5f53e6ee582410e4c66dfac312bc39c8ad4c9c633655cc675eeeeb1d2a4cdde1cf85ad88c2dae6bb34fdf4a179a2310569d2460e24337ff7bbbbfea594838d4abaf6a63c486cdbd290d7b026abb884417fd4d5f401dc5b12c92e9f7717dd36823bea76448dde348b5837f01d77d87e5162e2bcb9de2e4894c87e9b974f4a512f17bc0254cb4f969e6a518da4a1d72db5fdf8709ee9e220435bcb15c861e9ab2fa2a46ddc1789ca66b8ec8933d8f01a99982daff2b0e69fc9a1743734543bff06a24348790cb214614cadf397dc008df83a208b7d00dd84c63f5b01cf4ecc447bc8ed602ae1ba281f13ae6667b91ce4c86e42731e0fca64f53ad9fb12d91b4dc2f8046684642c650e297cd7d7364e1d3590264535ce3e1a9364356a561fbab40adc13e5fca03ac8e41958ef0e80cf09336c623cc2bfea2a26811e3124585ec5c4e31808c43d9e2da4f9185d5863ec837b01dd11caa2e4e8e69abbf0f27f339c6a65364c37fdaa70d62022f98f564fcd694c149e5e54a22ea1ea47fb14a57bf428a6ee3410f47f5357a3465a52337f51eca2ee3da15c3dab34373e2b9c7e6369fa2c67353d81cbe8bc470efd117b76aa4afd5f902e8d33baed1620ccbc9088b4b9276644520dbcf0b85a4660abd66280b68256eef87ae1ed44979c09588ebd8e3e29ee1d2c657e02985f7eae3659c65ecf6e421d737a7d0f2e504752b76bda244f54da9b3acffa8643c73bf237957de03b49791ee7e0d2f0df263721ef4cdd0f272f9793666a1426f49707ffa019e0b10d553cbd393270b0cd9c298f80af9fa64c0fc176d17d250d750974502c2b13e5db41b05009c2ac11cdef3be83448d08325772779b1105b8eea28ff99d1dc1be0ba310d623b957aebddbb2f21afd7f582f344930191a3a32b4a312e10d5ce1f0074a5970340ec6109c7ff681d0048487a81d7d48a6f9894c55f1dad40d3b53f6ad91c96f7e4249214c931f8e8160494ddc15c93b8e773a977ccf35ce2b8976f569db323072cfadca4ec16bc0e711ea527db63403730e5977ea40fcdf95acf9c19582e65b308dc6ce8a071cf34fb31821d12cb7f95ddeea200638c6bd7175043e69728d89683f7380cf407a9cc5168f71a26d3e3939519fe5cfc615728ae739c8fdcc1b7d7c3bf4dfeeda09775796bed9eb9c152885624925396d354df4ffad90e5072fe010a87026073f0bf385752586ed33d5a7c012ecff520f3d6193ffeea89c1dd24e087a33724da3c284b68e921bbd0e5316b6f7e69270adc02b4b6379d5bc162625d569d2879c0ccfbea00be90dd2b06c24fa6bb369e029066b891024451a709025f35b6c5b750284dce1f190f27b7e883c063009be932ac091f1d91b811a183ac9e36287cbc0019179b7d8c929ce15c8576591a6b6152b1ada24f09b89c32ac7b0a16e6cf07426cbecaaf510f978eaaa307ae6d9a72a00a67c8a01b3f6c0ce28bbac5be1717d04c29edde64d1e3591f0b945da81aa039bd11d71091e9b32a12630c05cf980a13b95e692fb517eef6aa4073ee84c6362e2581f26358d7e0590d2c01e65bb21420987639e98196cd99b221546c2036fe340749703a6e8d3e42230bf2c9f5d88c13681fee5df923ac9518bb396584605eb4cbf4ca305c2d631a073667923a5360de1e1065c37e5e6e89196b9ebc45d8d58ac3802577774f03a0a444a2aa0ab7a5c48991ed8cf235e452fb54ffe7ff47cfc7a7fd65d7f528c774244259ee42be909e655191afe6384b4e322c455a3ea577f25cf22fc3afba4669a8059b80aea8aa44ea5aa824e841c6d3038e99369344fce55ed963fb7b6c71a8645a912a7f3581c039b69efe532534f6184e1c75720bb4927ac48d2bb7f14da1796cad0c9d12d8e2d34247125642bcb6d4afcdf86c2bc93075ef0cbca190f011d41e2fdc98faf4191594e1b846c0270c51b95f52583d7af34996b2c3a4d681ab43fa92e080de8336a08ce6996eb9cdd186c65e0bee53d02dbc7cc392c008c7583a5697b6717af31cb45d53901ff9f839571da5c5cd2dd7c8c15214d0083f015d7d34f6f325bdea75f511343e5e5b0ab908ac913624a57a25f81a4ec14efb0169dc124bd57e88bde2954a2c6b28f060315838187ce86371c047c7a41b2246ce21c2fb1ef0b8ae6a79d3797cd1eb8a394017014a12d065262b8f6b86f5eb755e6f0d213a260a15f35e1397cb861a9c53ad9060ab7471e79c860020992fe623297532d4c80a5b8f89e38d7c9e6ce0d942831db8323229ed0697d66cadea9cb109ef99214341076f0ec2c48b13046845f6b58a2a5c9df688d044130754efb2f42fb9d671187135cf5ee13f9b4cdca5485e4cee7d4e0c48312c6c045dd5b42795783ee9d638f2c53c8272e6f35df718a9a996db2c58b8ccc832ed5645a87f3d8c39c66b52fdaeaed688c1a3f2e2f33553d2b84d63424d8fa459a76b0c6164810c6f8a7e054e03b8ca469df4971883f8f4373610d033af1e145f5783c9700e6c92307624ca07e8ee994db213054c208b388640a629c1a64b7b52efc669747563b806e8625ffff9c808314508d06f6baeae62ff0de970a27012dbf804652a3bf9337cfac726da2e99f3e5587285875b547546eddd1f9d56bf3700e510688aac8d30d69a647e0b243ef2be06fb8b96b5ce91d9b43e392fe2582678c7ff781d5d3c639e1130da409f99b805bb346cbd2f887931eaada8856c04624099dc41f6aa77f60c9b9bf54cb0a0877069147b80576d4de464c75b36b382be41d197d84cd69ad68074ef154d5f59d51b007f0abf8a8f4cd64b58b43e3f22fdacdeaf48994c77db58a641fa048dc4644cf0cd68f71f15dbf2cd33328a61b3d8839a46ad306d5d06446c278c3816e5ca2bd2287af3d7edde6585de41b1f7fbf9e5fb11c0d32ca3edc6d671ea913dc2c34e4d69eaabcb157cc82808089b598c5e9d580578a37f5fac414e072bb68b1ea3945e5c5403634278dfb8e51f54f44b341c4a831da010ccda597f022a7c2d1cb1b0629fe2a0cea1e9d058a3a16ccf4c556ad508a5ec3d3ae52bae5d38b2a0f2fc107a6bbef814b2a133eb91b246c2530aec54bbaf50cc6fb9b41c72e0b1f5ad1d1f5733bfce464336adf5d904eb0d323df52db3359b99e71f58e29fad0d5210d765da0b3174f4f88493bdaf83e5b5db224db8eef68d90b30ecc3c3398d0cf59340fc5fa0a721c6df426323020a5865d753e2ebd6dc7106dc20f7a0914aa765f4f1bc9ef87389ceb693afa77a09eecb2d57a8c8352c7206af0e8232c6dc793ae889566c7aa7e171f89a8165cd0d9cd9c2ff176f14603f4f23a528969fb0f103ae1b4c222cdd8991ffcd6243c2c34cf052aa65730abc59fd2301c4c3194371dd9f3ec3c2283032992725fe1bbdf1c568aa753fb0bf3465a4fb010ed1da136739251560167038d9a150694286c88585a3c61f8dae39c6d11e59e247f7dd2c57bdbf1212493b6cac723ae9a03112bcbd1ea44257b45c042aecbb3d86c5cefbcfef78e316b9494dfc8b009d88b37f8e883e0031d2b9eacc390ae334b2eef7338ade78bd0d4dbdc2f8c1ba7e3104d7985793b93d05f54d919ec333d71b9ecfe06409228c3c66e1ac4df691f2ab2fb45c2a0ef093ae7effc2029f77fe1c11b18c217d59465ef2d196b2b9e9726b63f8daa43aafa18dcbf5746f2491b092bb8ce58c783d63541bbcf192ee5623018e4285aca707d5eb15c8943373f69bcaf820184f6fa8f094b416f4ae018d0888bc606537bef176f70b17ee4e29a554e20d04a574dc70dae60a49a84f4864159801d3c9d7e8213423b053d4cc8693779072cff693fecba3feece033ba368c9ad18ec45f124b08d6332190a1b2897a97d3f525a114e0b9f5fae9171a0611a902be77163f62175fb3982c1ff15dba3c5360d602c8f5e1516d4e499914a1fb3f6cda6784c60ace5c4b98276cbd8c8ae0d4fa9b1a2d6c568f15fff8f773ddccb3f3370a2929df996cb74f4c8a9e5317c324a22b2ef6ed23a341eaf9bdf3b330ceb9845303ec9b912fde2d47b8136ac9e525af243d38ca93fadfd84c8eb67d5a221f281ffb35a5621acaea8a6aab68f785993e7047a0b23355b2ed5577224e650e938ba018d2f524f25d720ae23f2afa540aa50fbdd9619db69ed95e3e8b41a1fe2431111db5df474fe63364ca6eb9b4ac642d1d3788320b5974ea436a81fe03f7a4703f001f3557e912243f2e947952fde0fba1b88e54997f5651e2c741c7c2a174a945c4218a9ae592eaa71489accbd6262f4a574cf1aa57a57760b97b83b738a0bae5248623f7af4f90c6625bbd7dc3fc45dcead97a6736726364554507c4ebda1f3eab32c0e5b6d58ebcfc461dc394b9c1fbbe28f08460cda506596629773ce6d004ed9a62b44d8f10e600dea1b2149f70261e06edf738035e808d788c445a2294b0e1ae1996542ff087fb9889623a065b22fa099e35f897b24e6e911a8c3c7410cb0e8e942bd0d476bd0eb1b1642896b8427da60d55ad51492f0df22f8c696ee1440a7d5c2dca594b1ce8468799453fcca2a6540202edac6f2ad96d00d9ed7c67b2adcd415f13baf6f7b6f2b8ca1dc99e6e4e93d8f4bdc17c88f6266d818ff28fd618318583aa20af411bd6a3ca36cc16c19bb2e95795922cd849feb56eebeec0b497664b8cfec2785cc8d76f166108cc7dfc21ae7e7a5d289b37d29938cfa2a1c3c7f56c17f238a693c8fd98ebd919ff5d8b056200146a4c92b268795ca175159defc1a9470b00fcd58c7ba4f04d28eef531076cce781a33f89f2bbfe326647548b3e3ebe9952d435829908bf4e9e0162b2e82759632936725a0edee5f02500e6db6acc8fdb7f6e93d259bd5b0315a1aeed844c06a546638c7678c9dcb4a40475f865355ef94906b99737a0c1ac3b8da5c769e6a1a93068ef2befb15e48f23532dcd41bb8c3d8ac8fa3359a229e66ae800d62c4b74477949a75cd96fb012152370a72a08681b59a60ad02cffb14e69a44d5145288db122b09e22c6bf8b7f443996c3859d5b468efe6154d00d66b5285e8cb2752e684ff2b42af814cff376da0ec799db9e104d743b6c4864f71f401e4eab4bf66a3042c75928c95be191953a0aa8d43656d44b5001c42c54d61561a386eaae4a1802b13211c14703463948980ace0f26b5f06b8350dc4048d37d57feabae205ff4712118110c82bb2b6aad31e88c8eabad7f736bacf7a02762500e19ebd81d5653d63e05cc9410d0ac50164072601aad3ad5a6ad18818341cf97a3856db89f720aee5da0a8385f460c2c985002240b5b2fdc5def1831b9aaf0dcdecad43a70073cd4c1d9a82742a261e370cebdc7c94f6b3485367e62bb6f41013543b0a10005827a998726a83eec513287df35b82030535ab3f95f20011afa963105c2f7fda970a1c494690f144c52f80cfa62c98446b0c301ed0e4b07e178bc79c288d2cfe1738b62d2066abffe436a05e0c407d835951d37073bf57dd57e0d66c8aae39717f6075db4bab9ef544f225293b1a98775714e001309d85e968b6db204f1311db09cde56f3f88c86874d66c5d6d019ca996ee4b3a167836f61f3ad9dfd84ba29233929056aca4aea4ce1f0817dfc9e309ebdc97684ece539cbcf08dbf4fe743c45779b81c96bd91fdf5038f339176e5301349e37274eea0583d6011ada4a32e1c9b62e62dc08ab485cc4d7d74380889947b60ceb30d29d74bddde62a340b627722343d42f8239f706430578841c07aa5bc749d822d04a2b1f9d6c7bcaa339e8f4cec1950b7f369f5de3bae7f4113c0e607d21131199c3e78ed181bebcfe6f634ef5cab5484d97c0bbc0050e8ea139744db7624909496bfffd7e23cb480cce5c72469b72a987eff304e277095e4f1f24c1c68c227c2f3375651c45490ab39409aada691975c209ca2e0ef2d34cfeaed88ac2b72599bd11d523cee7727699b16805d068b2928216772fe774d1be22800d4487019b0623625ed93e5382a562d2969233ba424fc20da9f075834fba4e8d38f4d8c931023af6229dd5e8c328eb3e1d2f039822163c9fe153f324aa8dd66a54a62b0bd0cd6522eb9a7ddee3b225128c97f081bbe5c00e3e2d1e6d92e0ece67de4e4e6b8d10824bbbd5fabe10d1d293d86598b4524b9fc7cbd34d50924d1e2713b59dc6db76dc87b55aec0479a9e7ac89e8a067225e77b7924da9c01d3403decdad35a99ab824b4150b267001222184f7dde40a424086228b5dbb80ab59cfb0ee10ee0f77a80436499e1d0775ee0ade702e8af539e5d7b3e3023d8275e04f4edc44679709fa4bdd6ea5890206654a6f11bb51261ec3e2587e9a7baf9409f0cd88cdd8980189928731abd93f4d605a7c9dae2450e62a4aa3f50d4c466d5a00d0f290b64df96dd3790d249e277821450ed860e5312fa3a04555d3afd30bde35d8d38ef083999850dc6e01794c18fce7f0962731b25289cf955fef579fe82b18d145088fb923f374d714d8d415c03daa24c16280a486d311dfd95864ab0a6002e4838b2ac3a64a62b7b8347fbae994711fbfa95beacbbb91fb86da7db1c22cc83f294d211cac6c1510f44562e051f490e00ed5774acbe6ba498e6e817475b31036e572dc0068c048bc2d0161a237fc21e81d094105fa9c4888361643eba11202dfa817dc8499ae2c331f2fb2df635f97832ad0ff64aad46cbec0832009f44ced00cd417e659f2439229fb26aeeb607826ad2192c44ef18ec766fea594a5617e55ec1ff17c4fd33f40607cf750f78a15098ed220a1482d6293c2264bd2f1498e650d940035a90e381b79d03189d700683c0c2fbb14b6e2bb3c999b2d2e61abfba9bece086336523d4f37bd6fd729eec58bac5820a3b54794e41189ee1b0204a55cac23733a9944b8cd650e9f5496afb11d160ddcfab0cce1240ea8d8b6bbce18148d1807bc3cc6bab0e6f7877f02e576a7fe2c2564e3ec4f892964522dc9730d6e52315a7e7494d9220c62df242b6f1aab86159f62af8d7e5dec37e955087de91c517ce32c92d02473d59668f39099c5e91b5faa284975556257231d21506d1b6ef1901ac6f86aaa6fa0fbc94986de4c0c4c541d558e83dcb687f41ba9c8f544cc5a701f81229b6066e1c9fff719c0e11fea85f56d32fc2cd0348a4fff93efb6dc8e83664d20641320a12de1ed8116357c733407e719631ec78d28c4fbfba732a8b67c53f69a7e497c11e90fdc45aed614500625271d85d333130c0c110d22d7de5554a4ae2dac44793bd70802ba435a2e7c0f18a682cd8473f394fc3ed0aa33b15320fbc75a485a821cab983bbc74fc410c662db20d6a0959345710c54e180078e836abb5b203bdc9f288a5308c64442f269a56e632f0d8477f5496eefe23a0a387f89e8c47ac96ef5813531062d07e7bdb380341bf1246872e4196c4cecc7e98891d9ca62671cc4c5445e66b44ad14adc153c3721d29fbfdd42d57cde49d0af95723249ea353da9f852b75b8d945afa7e1f06fed3c59e636397cbf53aad74628ee80ab95368df02a79f83a7959c5b18dbc5b8b1ddbca5b8c975784779e2c342cce49aec4e89c8a38eb2b0a3424c3945797428ad61d1fdda5b06d4c19c46fe783ff693cfe387848ac764b7f18f9b2e5e328c7671d242b4cd628c403d89583256ec092769ad6321f163c57740aef0759c9dba3e5128e6c9da9cc138c28bfe7db9e8974b178f19625b2670e42b4d45c5b98f75d24fda1ac6af32cdfdaef2ec842ab2c817dd2d7b954e2f60bf884baf696965d1884408be01b595c35267d2701464b2d763eed93580ef61252ef6e1d48339dc8965671ad98aea7194b03361c175e9209498ab5c16efd9b7b9859bf09477596dbd8efe03c13bc86caf4a1c0f9343bff722a381f46f0f104edefbe34f71cd320248f915d6a97684933c2f68b4e848185c8905b1593d09ad5da70a8d82a759f842b7e802c03ea94d4394f8d231634d21351fe624bc71339d6ee3caeb529f9ac2c873eb08722023333c3bc53136ed92ffad6c9536a8a3fed566768571681d6067f3e1e83d53ea47aae3fb9bb6d9d0a682c9d8596cef9674856363f9cb96bc04777a8336771960190d3846529241d41191ab281689dea636659f8f13636ab8637ef62fb87292c75c0c09e224f79a91f51363e4c4a4cb4b708658074551c42cec0d9188555a8c1d448ab2a398b226c884756ac414e4594b81aa5d102637d050b8236cfffffb0dc24e4118621175cd51db4669fc367a684392476f98e70078fe71d8f266993865c9655cf33a8645629c59662a8fc3cdda668059242ec6178383813a9343e59f967963e4392e741b809c906daca71f28eeccce23f7ed61a467cd6bf25d0db552556af2868e0ceb919a91493e1b6cbf17d6f0201cced989452a5dd39a3cc6c4c8c3f691d3e864c911bd971fcf8d6858ac46919ac7309d06dfd793d36dcb9772e085348c625768a46d2ac61880265fa088649697124919be7ac6efb15f065b18762d75eea7a022f9d27e18c4cb78bdd140328a1c38e5adcb8f649ee0440f7e61d9b4ba07fbbe096619cf9a9e231cd3481955eee24082f0af8d043fdb8b8f353db0cace3118854a4aea67be6dc86b4423ca7a90b6afbe187ad38c8cd48c28ee40c48efafc75c68ebc891fecb15e7964650f7ec5b3309c4648a1147907efb95706644079632e18f7486a96e8d1e7216501f1c9627ba9482dca4895f8be21b290328483cd76d4eec755783652e4e78bdd1f1b04e5ce000ffaf2f3567f3b3a773747152b3cd7f880d1edd9702813251e894d77d021bff7b4f9892f324f077ff9bbaab257df458fd260cec459646bca2f5a685422000305e2b4019efdd260aa8cd654ccbb69dec62c9667b25fa20e7f28fa9690928e12b6362af167786aa11d6ad24f8715be7acce87bf754c4ae33b37e9c22062e90c32830b571ee54fa29258ebc82c65474f5aba606cddf3d9fc38ae1217f731ea95862b1f5fdfc9b1a57770de30f7f36556f191fd690624aeb01c4f330f4a10934cb6b497eb1b74767078bb468411662daf9205e2ad6d509860fe2cf30a0a135bb415923084a27ff3cfa78061abfd7bc869c8150f08d5bb984169d005048f3fc0a09584b19830a9bdec76c66b4709bd5cf9d9d2a7507d95cab5b9e4701dd16e71a5334cad28a2b5e7645916a97f912246df7ff186153a5ecb0369f70b5a73ecb0927f15fa275f691233671b89bef117ee7344ef9b49bded62eebf8db869eafdfaa86fb04aa7f8c48c6c9b53bd8cc9f7ddf86bf59e8d3d861ef3e1841af103dccb939c1d2e9eea51c8328c31805a670d013d2d9b45b34113b9f118e1e298bdaf23c851ee4e7a1a3fabb28eb5e05ac968906eddc39853c87adacdbfaeebf793872ab36505d3bd01564916b85bac33d60be0b8b66fbea72e8e8387960be72051570af09d5af72327e51e60511a5a76735843bf867bd74fbbfd77b88912a4fed04c702c1c51f028db54ae86053b183e77e2442d799ee186b8eff496cb58ecb379c89889b6c384d8858e294b7baae31c32ee8a465c18c6244adba008a2798cb3e578355290296e34525c25b1397237b48cdfa0020ec707ce9aff73fb40deb83f56a762a97821f6a02ab5aeebd078b3c20909f1f75cb416e5960360535becbf585318d38ba2043bf516ffe54e773062949fc20b5c0136d01fbb6a98fdd011e3647eb6e57140c3907dd625d0217f95a7f20acb1aab48ddd44e27a40b691e95f0e87dcb0d580b4687c3fad68127366b9dde2e24293fed74194c13b18b477e3e5a62440a137df0df7d504a62c38900829737d9458cfee09752f228b32864a46b3afe9d22c392e4ca1cb54ca0988142d712c94891f50b8af425629bb25d49bcfa366640df9217d28aa10e43d2a38b47d8d8f440f22a8e2c7df4bf2c966783e38fab1a8fe5ee0a4af6d9ec099655403776e0d25e255f24265fd3ad5f75d2295813bc80d34bf8592dc05c784f94476a3034bd16865c2726de6f97981e35e44f1521580dc01a0e20b10595c3c438bade0703647f487581479ed5dbe29724eabb21b9eaae94eab7ee18271cf90128bb2f1d141b361fb288544ddfd18340a76a6cd0f70f7b54efc291c1521092799943c3e381aac1b707be325d11e715eddc8831978acf310a50c965af46f6eabbbf56ebed62981e02e66f45e77f8f8f534bc3ee3a548b2cff0a3a7643c7bd2d3c0d1d806dae2294c03a8bb61822d092aa45dbcef1fcc134b994f6497cabb767ed73be96745614e5ae5b0a7f880f5912e5419d7ba4f57c0feed8424330327aabf6618e0e152c7bbba4645d950bf47b74b16befc9e9008147c6fa02c80431b543d7347205c8662cc20c450e745ab7aaeac21cc0242d1f2921b4decb9a513d63749fbfdf0868752035fdf8f229e6b1cdbc4d3b28c3890e3989e5184b97e4d24a58ee8c99ed8fd0ae1aab5c7f28695e6d5f332d067180818adecedcbc766cc33720bb255353f9d1588d5594b82028197a2ec818c26418ecd2842bb50279580e095acb6fc165c1ddac3cb84da4b21489fe9e96cd1a4d19b9837cbaff30ec432f22b06a92d256a66459e4bc84ba65eb9f4effbf4e833d06ef184de97ca0f7e1cd18f3eed8205654fbc799aed3cc36ac2b1f2983a093afcc1a9e8f084bde1456d0dd5cb6eefd7926fda8c82a2ea4b8bf55b1a78beba0a8e1952d2c3d01b9ea31d259598fa28163fc68074b75d586241ce3c34975fc9e59e8c43bb7d363bf68924ebce45889f702ece2e6d6c2886553b097bfa0239bedecd3030f9df0a39f590b231d146673285ba9c588dbfbc6d9d15030f683a545e56db9ceb880a9269c1ccbec6ce87f8d4be0d670257020156faef244ff702382a8721cde2e2b554a11520a88c9882d683c533118673747eff3760a60c2c2f24daf850edf4b209907f893049fc794ad6d9475e457cf5e1dd419299adc9ef903a25e224b7a59705f910850111748ca020965e3e49fe5cb8ad1650a70c8355f65e604c0bb362223573aa9c2afa5136e2894c5fd9cc97e27d837e5f2d2370545c105adf9332de1498ffd947daed7a934a00c6b27e1778a3610338b5b17c2673de5d1d5b2320d592c07f3a57b93b8e2961bd0f829dc839c8b0a4c040b7f893ae1689a60c2068ab72011592c4c2ee818d582fd0452502ac96564a6adadaf89a8620867792839a0c1d08298749e524ba00d0c7bb92e8da562efd299b76bba2cc8acf2f93e0661f14445dbf33a7eda91343ccc7d93a1143ee97f26962bb9bbd113bac45442908d8bfcd131ea3f55828662e44c1eb70d722c75db0ac9b8db77eb69276557befbf4457f4956f6cae242c3254b56ef031e1148768d425c4f0644a454fa106e8b65f99f0c1163939e5066eff9404a0b638c1ced86b05cdb30864d001815ea4030a7b4e5b9e9c524610e526404e7e5c8c569660348485bb232602bc9ec776003ce30e57c1f7ce81e1dc41d58ebc9269401047e7f34df4eb36295592beef8dbbf0fe846196f67066bcb1ace818db643a4fdcf2c8ff4883309a0ff7842415db9ff31cadda0ed6d4e7432793dd31c62b4a43e409f56ceb4295aa1cbf98797c8da76b25ba8e21924a986910596e03388033026cfc2e7a9742917098ff98b1549f87dd2ad7d34e57bf05b43031bba085a2bff46ac811a0c5b971a53b876b1636841e700d846b04ec14fb43018e463812ce268848fa06b99c4f95c64e2d11144730877c1e68a588c196f35b7dd03ddac04d493d115fcec7c3b5050ee22ad56c46da11caf3cbd0ef1621289937e876c720cc62e31528d5c7443c6526e994c9d960aa431683a2b5416ef44627007a7c9c5eb6eebdc80734d71","isRememberEnabled":true,"rememberDurationInDays":"1","staticryptSaltUniqueVariableName":"b62aec05d4f0bac06519546b0a64be0b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
